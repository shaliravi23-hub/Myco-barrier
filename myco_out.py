#!/usr/bin/python3

import time
import re
from mininet.net import Mininet
from mininet.node import RemoteController, OVSKernelSwitch, Host
from mininet.link import TCLink
from mininet.topo import Topo
from mininet.log import setLogLevel, info
from mininet.cli import CLI

# ==========================================
# 1. Topology Definition (Realistic IoT Tree)
# ==========================================
class MycoIoTTopo(Topo):
    """
    Realistic IoT Topology with N=50 hosts.
    Structured as a Tree: Core -> Aggregation -> Edge -> Hosts
    to simulate network depth and backhaul contention.
    """
    def build(self, n=50):
        # Create Core Switch
        core_switch = self.addSwitch('s1')

        # Create Aggregation Switches (1 agg switch per 10 hosts)
        agg_switches = []
        for i in range(1, 6):
            sw = self.addSwitch(f's10{i}')
            agg_switches.append(sw)
            # Connect Aggregation to Core (Backhaul)
            # 10Mbps, 5ms latency as requested
            self.addLink(sw, core_switch, bw=10, delay='5ms', use_htb=True)

        # Create Hosts and attach to Aggregation Switches
        for i in range(1, n + 1):
            host = self.addHost(f'h{i}') # Limit CPU to prevent simulation artifacts
            
            # Determine which aggregation switch this host belongs to
            # Distribute 50 hosts across 5 switches (10 per switch)
            switch_idx = (i - 1) // 10
            parent_switch = agg_switches[switch_idx]
            
            # Connect Host to Switch (IoT Link)
            self.addLink(host, parent_switch, bw=10, delay='5ms', use_htb=True)

# ==========================================
# 2. Metrics & Traffic Logic
# ==========================================
def run_myco_test(net):
    info(f"\n*** Starting Myco-Barrier Strategy Evaluation ***\n")
    info(f"*** Setup: N=50, BW=10Mbps, Delay=5ms, UDP=500kbps ***\n")
    
    # Wait for controller to learn topology
    info("*** Waiting 5 seconds for Controller/Switch handshake...\n")
    time.sleep(5)

    hosts = net.hosts
    # Assume h1 is the 'Sink' or 'Gateway' node for IoT traffic
    server = hosts[0] 
    clients = hosts[1:]

    info(f"*** Starting Iperf Servers on Gateway ({server.name})...\n")
    # Start Iperf server in background, formatting output to CSV for easier parsing
    server.cmd('iperf -s -u -i 1 -y C > iperf_server_log.txt &')

    info("*** Generating Background Traffic (Stress Test)...\n")
    # Generate 500kbps UDP stream from all nodes to the sink
    for client in clients:
        # -u: UDP, -b: Bandwidth, -t: Duration
        client.cmd(f'iperf -c {server.IP()} -u -b 500K -t 20 &')
    
    # Allow traffic to run for the duration
    progress_bar(20)

    # ------------------------------------------------
    # Metric 1: Control Plane Latency (Approximated via Ping)
    # ------------------------------------------------
    info("\n*** Measuring Latency (L_ctrl Proxy)... \n")
    # We ping from the last host to the first to traverse the whole network depth
    ping_result = clients[-1].cmd(f'ping -c 10 {server.IP()}')
    
    # Parse Ping Output
    avg_rtt = 0.0
    try:
        rtt_line = [line for line in ping_result.split('\n') if 'rtt min/avg' in line][0]
        avg_rtt = float(rtt_line.split('/')[4])
        info(f"-> Average Network Latency: {avg_rtt} ms\n")
    except:
        info("-> Latency measurement failed (Packet Loss?)\n")

    # ------------------------------------------------
    # Metric 2: Throughput & PDR (Packet Delivery Ratio)
    # ------------------------------------------------
    info("*** Analyzing Traffic Stability (PDR & Throughput)...\n")
    
    # Kill iperf server to flush logs
    server.cmd('killall -9 iperf')
    
    # Read the log file generated by the server
    # Format of -y C: timestamp, sender_ip, sender_port, dest_ip, dest_port, id, interval, transfer, bandwidth, jitter, lost, total, %loss, read_error
    total_sent = 0
    total_lost = 0
    avg_throughput = 0
    count = 0

    try:
        with open('iperf_server_log.txt', 'r') as f:
            for line in f:
                parts = line.strip().split(',')
                if len(parts) > 12:
                    # UDP stats are usually at the end of the session in CSV
                    lost = int(parts[10])
                    total = int(parts[11])
                    bps = int(parts[8])
                    
                    total_lost += lost
                    total_sent += total
                    avg_throughput += bps
                    count += 1
        
        # Calculate PDR
        if total_sent > 0:
            pdr = 100 * (1 - (total_lost / total_sent))
        else:
            pdr = 0
            
        # Convert throughput to Mbps
        avg_throughput_mbps = (avg_throughput / count) / 1e6 if count > 0 else 0

        info(f"-> Aggregated Throughput: {avg_throughput_mbps:.2f} Mbps\n")
        info(f"-> Packet Delivery Ratio (PDR): {pdr:.2f}%\n")
        info(f"-> Total Packets Lost: {total_lost}/{total_sent}\n")

    except Exception as e:
        info(f"-> Error parsing metrics: {e}\n")

    info("\n*** Test Complete. ***\n")

def progress_bar(seconds):
    """Simple progress bar"""
    for _ in range(seconds):
        time.sleep(1)
        print('.', end='', flush=True)
    print()

# ==========================================
# 3. Main Execution
# ==========================================
if __name__ == '__main__':
    setLogLevel('info')

    # Define the Remote Controller (Must be running Ryu separately)
    # OpenFlow 1.3 is strictly enforced
    c0 = RemoteController('c0', ip='127.0.0.1', port=6633, protocols="OpenFlow13")

    # Initialize Network
    topo = MycoIoTTopo(n=50)
    net = Mininet(topo=topo, 
                  link=TCLink, 
                  controller=c0, 
                  switch=OVSKernelSwitch,
                  host=Host,
                  autoSetMacs=True)

    try:
        net.start()
        # Verify connectivity before stressing
        # info("*** specific Myco-Scout discovery phase (PingAll)...\n")
        # net.pingAll() 
        
        # Run the metric collection
        run_myco_test(net)
        
        # Drop into CLI for manual debugging if needed
        # CLI(net) 
    except Exception as e:
        info(f"*** An error occurred: {e}\n")
    finally:
        net.stop()
        # Clean up residual processes
        print("Cleaning up...")
        import os
        os.system('sudo mn -c > /dev/null 2>&1')
